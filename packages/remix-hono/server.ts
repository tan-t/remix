// IDK why this is needed when it's in the tsconfig..........
// YAY PROJECT REFERENCES!
/// <reference lib="DOM.Iterable" />

import type * as hono from "hono";
import type { AppLoadContext, ServerBuild } from "@remix-run/node";
import {
  createRequestHandler as createRemixRequestHandler,
} from "@remix-run/node";

/**
 * A function that returns the value to use as `context` in route `loader` and
 * `action` functions.
 *
 * You can think of this as an escape hatch that allows you to pass
 * environment/platform-specific values through to your loader/action, such as
 * values that are generated by Hono middleware like `req.session`.
 */
export type GetLoadContextFunction = (
  req: hono.HonoRequest,
) => Promise<AppLoadContext> | AppLoadContext;

export type RequestHandler<X extends hono.Env> = hono.Handler<X>;
/**
 * Returns a request handler for Hono that serves the response using Remix.
 */
export function createRequestHandler<X extends hono.Env>({
  build,
  getLoadContext,
  mode = process.env.NODE_ENV,
}: {
  build: ServerBuild | (() => Promise<ServerBuild>);
  getLoadContext?: GetLoadContextFunction;
  mode?: string;
}): RequestHandler<X> {
  const handleRequest = createRemixRequestHandler(build, mode);

  return async (
    c: hono.Context<X>
  ) => {
    const request = createRemixRequest(c.req.raw);
    const loadContext = await getLoadContext?.(c.req);

    const response = await handleRequest(request, loadContext);

    await sendRemixResponse(c, response);
  };
}

export function createRemixHeaders(
  requestHeaders: Request["headers"]
): Headers {
  const headers = new Headers();

  for (let [key, values] of Object.entries(requestHeaders)) {
    if (values) {
      if (Array.isArray(values)) {
        for (let value of values) {
          headers.append(key, value);
        }
      } else {
        headers.set(key, values);
      }
    }
  }

  return headers;
}

export function createRemixRequest(
  req: Request
): Request {
  // req.hostname doesn't include port information so grab that from
  // `X-Forwarded-Host` or `Host`
  let [, hostnamePort] = req.headers.get("X-Forwarded-Host")?.split(":") ?? [];
  let [, hostPort] = req.headers.get("host")?.split(":") ?? [];
  let port = hostnamePort || hostPort;
  // Use req.hostname here as it respects the "trust proxy" setting
  const urlObject = new URL(req.url);
  let resolvedHost = `${urlObject.hostname}${port ? `:${port}` : ""}`;
  let url = new URL(`${resolvedHost}${req.url}`);

  // Abort action/loaders once we can no longer write a response
  let controller = new AbortController();

  let init: RequestInit = {
    method: req.method,
    headers: createRemixHeaders(req.headers),
    signal: controller.signal,
  };

  return new Request(url.href, init);
}

export async function sendRemixResponse(
  ctx: hono.Context,
  original: Response
): Promise<void> {
  ctx.res = original;
}
